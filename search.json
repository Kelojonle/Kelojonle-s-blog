[{"title":"线段树学习笔记","url":"/2024/11/16/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"线段树学习笔记对线段树的介绍\n线段树是一种树形数据结构，属于二叉树\n一棵线段树的每个结点都可以用区间[l,r]来表示。线段树的叶结点表示的区间为[l,l]或[r,r]。\n线段树支持单点修改，区间修改，区间和&#x2F;区间最值等的查询。\n对于线段树的区间修改一般采用延迟修改方式\n线段树的每一棵子树要么只有一个root，要么就是一棵满二叉树\n\n\n线段树的建树线段树的表示因为线段树是一棵二叉树，所以可以采用与二叉堆一致的表示法：\n编号为p的结点的\n1.左结点的编号为p*2\n2.右结点的编号为p*2+1。\n类似二叉堆，线段树是一个结构体数组。\nstruct SegmentTree&#123;    int l,r;// 表示该结点代表的区间    int dat;//区间[l,r]的最大值    int add;//延迟修改标记&#125;\n线段树的结点为了避免最最让人难受的RE，所以考虑一棵线段树的最大结点数。\n设现在需要表示区间[1,n]，使得构造的线段树为一棵满二叉树。\n由线段树的性质得知，该二叉树有n个叶结点，则总结点数为n＋n&#x2F;2+···+2+1，即4n-1。\n因为我的个人习惯，我一般会不处理一个数组的第一个元素，即下标为0的元素。\n#include&lt;bits/stdc++.h&gt;using namespace std;struct SegmentTree&#123;    int l,r;// 表示该结点代表的区间    int dat;//区间[l,r]的最大值    int add;//延迟修改标记&#125; t[4*1000001];int va[114514];//区间是数组下标区间，这是线段树叶结点实际代表的值void bulid(int l,int r,int p)// 结点的数组下标为p，表示区间[l,r]&#123;    t[p].l = l;//代表区间初始化    t[p].r = r;    if(l == r)//叶结点    &#123;        t[p].dat = va[l];        return;// 如果你想RE，建议删去这行    &#125;    int mid = (l + r) / 2;    bulid(l,mid,p*2);// 左子结点    bulid(mid+1,r,p*2+1);//右子结点    t[p].dat = max(t[p*2].dat,t[p*2+1].dat);//自下往上更新数据&#125;int main()&#123;    //略&#125;\n线段树的区间修改&amp;延迟修改区间修改对于访问到的每一个结点，如果修改范围完全包括了它，那么直接修改+打延迟修改标记。否则：\n1.若修改范围与该结点的左结点有重合，则递归修改左结点\n2.若修改范围与该结点的右结点有重合，则递归修改右结点\ncode:\n#include&lt;bits/stdc++.h&gt;using namespace std;void change(int l,int r,int add,int p)//add 为区间修改所要加上的值&#123;    if(l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)    &#123;        t[p].add += add;        t[p].dat += add;        return ;    &#125;    int mid = (l + r) / 2;    if(l &lt;= mid)    &#123;        change(l,r,add,p*2);    &#125;    if(mid &lt; r)    &#123;        change(l,r,add,p*2+1);    &#125;&#125;\n延迟修改:延迟修改的含义并不是当访问到该结点时在进行修改，而是在访问到它时，它已经被修改，若其不是叶结点，则给它的两个子结点，进行对应修改并打上标记，代表该结点已被修改，但其子结点没有被修改。\ncode:\n#include&lt;bits/stdc++.h&gt;using namespace std;void spread(int p)// p为父结点下标&#123;    if(t[p].add &amp;&amp; t[p].l != t[p].r)    &#123;        t[p*2].add = t[p*2+1].add = t[p].add;//给子结点打标记        t[p*2].dat += t[p].add;        t[p*2+1].dat += t[p].add;//因为是最大值，所以直接加上就行        t[p].add = 0;//删除标记    &#125;&#125;int main()&#123;    //略&#125;\n线段树的区间查询对于访问到的每一个结点，如果查询范围完全包括了它，那么直接返回。否则：\n1.若查询范围与该结点的左结点有重合，则递归查询左结点\n2.若查询范围与该结点的右结点有重合，则递归查询右结点\ncode：:\n#include&lt;bits/stdc++.h&gt;using namespace std;typename ask(int l,int r,int p)&#123;    if(l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)    &#123;        return t[p].dat;    &#125;    int mid = (l + r) / 2;    if(l &lt;= mid)    &#123;        ask(l,r,p*2);    &#125;    if(mid &lt; r)    &#123;        ask(l,r,p*2+1)    &#125;&#125;\n完结To be continued\n"}]